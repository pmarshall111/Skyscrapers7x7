{"version":3,"file":"Solver.js","sourceRoot":"","sources":["Solver.ts"],"names":[],"mappings":"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","sourcesContent":["import {Perms} from \"./Perms\";\nimport {Grid} from \"./Grid\";\n\nexport class Solver {\n    private numbBuildings: number;\n    startTime: number;\n    rules: number[];\n    permutationBuilder: Perms;\n    solution: Grid;\n\n    //for exceptionally big problems (7x7+), heap size may need to be increased.\n    getBoard(clues: number[]) {\n        this.startTime = new Date().getTime();\n        this.rules = clues;\n        this.numbBuildings = clues.length/4;\n\n        let empty2dArray = Grid.getBlankGrid(this.numbBuildings);\n        let possibleNumbers: Set<number>[][] = this.createPossibleNumbers(this.numbBuildings);\n        let startGrid = new Grid(empty2dArray, possibleNumbers);\n\n        this.addDefinites(startGrid);\n        startGrid.fillInBlanks(); //fillInBlanks will check for negatives. i.e. will add a number it's the only square in it's row or col that can have that number\n\n        let permutationBuilder = new Perms();\n        let toLookThrough = [startGrid];\n        let createdThisIteration = [];\n\n        while (toLookThrough.length) {\n            for (let i = 0; i<toLookThrough.length; i++) {\n                let grid = toLookThrough[i];\n                let indexes = grid.getBestRows(clues);\n                let perms = indexes.map(x => {\n                    let {row, possibleNumbs} = grid.getRow(x.index);\n                    let clue = clues[x.index];\n                    let oppositeClue = clues[Solver.getOppositeClueIndex(x.index, this.numbBuildings)];\n                    let permutations = permutationBuilder.getPerms(row, possibleNumbs, {left: clue, right: oppositeClue});\n                    return {index: x.index, perms: permutations, score: x.score}\n                }).sort((a,b) => a.perms.length-b.perms.length);\n\n                let selectedPerms = perms[0].perms;\n                for (let i = 0; i<selectedPerms.length; i++) {\n                    let sol = selectedPerms[i];\n                    let newGrid = grid.copy();\n                    newGrid.saveRow(sol.row, perms[0].index);\n                    newGrid.fillInBlanks();\n                    let completed = newGrid.isComplete();\n                    if (completed && newGrid.matchesClues(clues) && newGrid.noDuplicateNumbers()) {\n                        return [newGrid];\n                    } else if (!completed) {\n                        createdThisIteration.push(newGrid);\n                    }\n                }\n            }\n            toLookThrough = createdThisIteration;\n            createdThisIteration = [];\n        }\n        return [];\n    }\n\n    //method uses recursive solution so the number of grids held in memory is far fewer.\n    //for exceptionally big problems (7x7+), call stack size may need to be increased.\n    getBoardHeapEfficient(clues: number[]) {\n        this.startTime = new Date().getTime();\n        this.rules = clues;\n        this.numbBuildings = clues.length/4;\n        this.permutationBuilder = new Perms();\n\n        let empty2dArray = Grid.getBlankGrid(this.numbBuildings);\n        let possibleNumbers: Set<number>[][] = this.createPossibleNumbers(this.numbBuildings);\n\n        let startGrid = new Grid(empty2dArray, possibleNumbers);\n        this.addDefinites(startGrid);\n        startGrid.fillInBlanks(); //fillInBlanks will check for negatives. i.e. will add a number it's the only square in it's row or col that can have that number\n        this.addRow(startGrid);\n        return this.solution;\n    }\n\n    addRow(g: Grid) {\n        if (this.solution) {\n            return;\n        }\n\n        let indexes = g.getBestRows(this.rules);\n        let perms = indexes.map(x => {\n            let {row, possibleNumbs} = g.getRow(x.index);\n            let clue = this.rules[x.index];\n            let oppositeClue = this.rules[Solver.getOppositeClueIndex(x.index, this.numbBuildings)];\n            let permutations = this.permutationBuilder.getPerms(row, possibleNumbs, {left: clue, right: oppositeClue});\n            return {index: x.index, perms: permutations, score: x.score}\n        }).sort((a,b) => a.perms.length-b.perms.length);\n\n        let selectedPerms = perms[0].perms;\n        for (let i = 0; i<selectedPerms.length; i++) {\n            let sol = selectedPerms[i];\n            let newGrid = g.copy();\n            newGrid.saveRow(sol.row, perms[0].index);\n            newGrid.fillInBlanks();\n            let completed = newGrid.isComplete();\n            if (completed && newGrid.matchesClues(this.rules) && newGrid.noDuplicateNumbers()) {\n                this.solution = newGrid;\n            } else if (!completed) {\n                this.addRow(newGrid)\n            }\n        }\n    }\n\n\n    //squaresAway of 0 is closest square\n    static getSquareXFromClue(clueIndex: number, squaresAway: number, rowLength: number) {\n        let timesIntoRows = Math.floor(clueIndex/rowLength);\n        let rowIdx, colIdx;\n\n        if (timesIntoRows == 0) {\n            rowIdx = 0 + squaresAway;\n            colIdx = clueIndex;\n        } else if (timesIntoRows == 1) {\n            rowIdx = clueIndex % rowLength;\n            colIdx = rowLength-1 - squaresAway;\n        } else if (timesIntoRows == 2) {\n            rowIdx = rowLength-1 - squaresAway;\n            colIdx = rowLength-1 - clueIndex % rowLength;\n        } else {\n            rowIdx = rowLength-1 - clueIndex % rowLength;\n            colIdx = 0 + squaresAway;\n        }\n\n        return {rowIdx, colIdx};\n    }\n\n  createPossibleNumbers(numbRows: number): Set<number>[][] {\n      let possibleNumbers: Set<number>[][] = [];\n      let allNumbers = [];\n      for (let i = 1; i<=numbRows; i++) {\n          allNumbers.push(i);\n      }\n\n      for (let i = 0; i< numbRows; i++) {\n          let rowArr = [];\n          possibleNumbers.push(rowArr);\n          for (let j = 0; j<numbRows; j++) {\n              rowArr.push(new Set(allNumbers))\n          }\n      }\n      return possibleNumbers;\n  }\n\n  addDefinites(startGrid: Grid) {\n      for (let i = 0; i<this.rules.length; i++) {\n          let clue = this.rules[i];\n          let oppositeClue = this.rules[Solver.getOppositeClueIndex(i, this.numbBuildings)];\n\n          this.addSpecialCases(startGrid, clue, oppositeClue, i);\n\n          //removing numbers that would make the row impossible\n          // i.e. if we want to see 3 buildings, the largest building cannot be in the first square.\n          for (let c = clue; c>=2; c--) {\n              let toRemove = this.numbBuildings - (clue-c);\n              let squaresAway = c-2;\n              while (squaresAway >= 0) {\n                  let {rowIdx, colIdx} = Solver.getSquareXFromClue(i, squaresAway, this.numbBuildings);\n                  startGrid.updatePossibleNumbersNumbNotAllowed(toRemove, rowIdx, colIdx);\n                  squaresAway--;\n              }\n          }\n      }\n  }\n\n  addSpecialCases(startGrid: Grid, clue: number, oppositeClue: number, clueIndex: number) {\n      if (clue == 1) {\n          //closest square must be largest building\n          let {rowIdx, colIdx} = Solver.getSquareXFromClue(clueIndex, 0, this.numbBuildings);\n          startGrid.saveSquare(this.numbBuildings, rowIdx, colIdx);\n          if (oppositeClue == 2) {\n              //opposite clue must then have second largest building as closest square.\n              let {rowIdx, colIdx} = Solver.getSquareXFromClue(clueIndex, this.numbBuildings-1, this.numbBuildings);\n              startGrid.saveSquare(this.numbBuildings-1, rowIdx, colIdx);\n          }\n      } else if (clue == 2) {\n          //second square cannot be second largest number\n          let {rowIdx, colIdx} = Solver.getSquareXFromClue(clueIndex, 1, this.numbBuildings);\n          startGrid.updatePossibleNumbersNumbNotAllowed(this.numbBuildings-1, rowIdx, colIdx);\n          if (oppositeClue == 2) {\n              //second largest building has to be on edge. removing from all middle elements\n              for (let squaresAway = 1; squaresAway<this.numbBuildings-1; squaresAway++) {\n                  let {rowIdx, colIdx} = Solver.getSquareXFromClue(clueIndex, squaresAway, this.numbBuildings);\n                  startGrid.updatePossibleNumbersNumbNotAllowed(this.numbBuildings-1, rowIdx, colIdx);\n              }\n          }\n      } else if (clue == 3 && oppositeClue == 1) {\n          //2 lower than tallest building cannot go in second spot\n          let {rowIdx, colIdx} = Solver.getSquareXFromClue(clueIndex, 1, this.numbBuildings);\n          startGrid.updatePossibleNumbersNumbNotAllowed(this.numbBuildings-2, rowIdx, colIdx);\n      } else if (clue + oppositeClue == this.numbBuildings + 1) {\n          //tallest building must go clue-1 spaces away\n          let {rowIdx, colIdx} = Solver.getSquareXFromClue(clueIndex, clue-1, this.numbBuildings);\n          startGrid.saveSquare(this.numbBuildings, rowIdx, colIdx);\n      } else if (clue == this.numbBuildings) {\n          //all buildings must be shown in ascending order\n          let row = new Array(this.numbBuildings).fill(-1).map((x,idx) => idx+1);\n          startGrid.saveRow(row, clueIndex);\n      }\n  }\n\n    static getOppositeClueIndex(index: number, numbRows: number) {\n        let moduloIndex = index % numbRows;\n        let timesDividesIn = Math.floor(index/numbRows);\n        return numbRows*((timesDividesIn+2)%4 +1) - moduloIndex-1;\n    }\n}\n\n\n//4x4\n// let clues = [\n//     0,0,1,2,\n//     0,2,0,0,\n//     0,2,0,0,\n//     4,1,0,0\n// ]\n\n//5x5\n// let clues = [ 0, 3, 0, 4, 3,\n//     0, 2, 0, 1, 2,\n//     0, 0, 0, 0, 0,\n//     3, 2, 0, 3, 0,];\n\n\n//6x6\n// let clues = [ 0, 3, 0, 5, 3, 4,\n//     0, 0, 0, 0, 0, 1,\n//     0, 3, 0, 3, 2, 3,\n//     3, 2, 0, 3, 1, 0];\n\n\n//8x8\n//<1s\n// let clues = [3,0,3,3,2,3,0,3,\n//             4,3,0,1,5,0,3,0,\n//             0,0,2,0,2,3,4,0,\n//             0,3,4,2,0,0,0,0];\n\n\n//8x8\n//2mins\n// let clues = [3,2,4,3,2,1,3,3,\n//     3,3,1,3,4,2,2,4,\n//     3,2,4,2,3,2,5,1,\n//     1,3,2,3,3,3,2,3];\n\n\n//8x8\n//max heap size reached.\n//using stack method solves in 0.4s\n// let clues = [1,3,5,3,4,3,2,2,\n//             2,2,1,3,3,2,5,4,\n//             3,5,2,2,3,1,2,6,\n//             3,2,4,3,2,2,4,1];\n\n\n// let sol = new Solver();\n// sol.getBoardHeapEfficient(clues).printGrid();\n// sol.getBoard(clues).forEach(x => x.printGrid());\n// console.log((new Date().getTime() - sol.startTime)/1000);\n"]}