{"version":3,"file":"Perms.js","sourceRoot":"","sources":["Perms.ts"],"names":[],"mappings":"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","sourcesContent":["import {PermInfo} from \"./PermInfo\"\n\ndeclare function require(path: string): any;\n\nconst util = require('util');\n\nexport class Perms {\n    getPerms(startRow: number[], possibleNumbers: Set<number>[], clues: { left: number, right: number }): PermInfo[] {\n        let firstRecord = PermInfo.getFirstRecord(startRow);\n        if (firstRecord.numbsUsed.size == firstRecord.row.length) {\n            //then perm is already solved\n            return [];\n        }\n        let currPerms: PermInfo[] = [firstRecord];\n        let nextIterPerms: PermInfo[] = [];\n        //goes through all permutations for the same index\n        for (let i = firstRecord.nextIndex; i < startRow.length; i++) {\n            for (let p = 0; p < currPerms.length; p++) {\n                let currentPerm = currPerms[p];\n                if (startRow[i] == -1) {\n                    let possNumbs = new Set(possibleNumbers[i]);\n                    currentPerm.numbsUsed.forEach(n => possNumbs.delete(n));\n                    if (possNumbs.size > 0) {\n                        for (let val of possNumbs.values()) {\n                            let perm = this.permForNextIteration(currentPerm, val, clues, i);\n                            if (perm != null) {\n                                nextIterPerms.push(perm);\n                            }\n                        }\n                    }\n                } else {\n                    //even though number already in row, still need to get a permRecord for next iteration as it keeps track\n                    //of whether the row adheres to the clues.\n                    let val = startRow[i];\n                    let perm = this.permForNextIteration(currentPerm, val, clues, i);\n                    if (perm != null) {\n                        nextIterPerms.push(perm);\n                    }\n                }\n            }\n            currPerms = nextIterPerms;\n            nextIterPerms = [];\n        }\n        return !clues.right ? currPerms : currPerms.filter(x => x.validateFromRHS(clues.right));\n    }\n\n    //checks left and right clues but for the right clue it can only filter out if it's definite that more buildings will be shown than desired.\n    //this was done for performance reasons so that only 1 loop is needed to go through a permutation. Once created, the RHS is checked with a\n    //call to validateToRHS on the PermInfo returned class.\n    //therefore if only have 1 clue, call with the clue on LHS.\n    permForNextIteration(currentPerm: PermInfo, val: number, clues: { left: number, right: number }, index: number): PermInfo {\n        //alter left count\n        let countLeft = currentPerm.countLeft;\n        let highestFromLeft = currentPerm.highestFromLeft;\n        if (val > currentPerm.highestFromLeft) {\n            countLeft = currentPerm.countLeft + 1;\n            highestFromLeft = val;\n        }\n        //alter right count\n        let biggestNotUsed = currentPerm.biggestNotUsed;\n        let guaranteedRight = currentPerm.guaranteedFromRight;\n        if (val == currentPerm.biggestNotUsed) {\n            guaranteedRight++;\n            biggestNotUsed = PermInfo.getNextBiggestNotUsed(val, currentPerm.seenPriorToIndex)\n        }\n        //guaranteed different in that it includes the final element as guaranteed to be seen\n        let willBeSeenRight = guaranteedRight + (index < currentPerm.row.length - 1 ? 1 : 0);\n        let moreNeededLeft = clues.left - countLeft;\n        let available = currentPerm.row.length - highestFromLeft;\n\n        if ((!clues.left || (moreNeededLeft <= available && moreNeededLeft >= 0)) && (!clues.right || willBeSeenRight <= clues.right)) {\n            let newRow = currentPerm.row.slice();\n            newRow[index] = val;\n            let newPerm = new PermInfo(newRow,\n                                        new Set<number>(currentPerm.numbsUsed).add(val),\n                                        new Set<number>(currentPerm.seenPriorToIndex).add(val),\n                                        highestFromLeft,\n                                        biggestNotUsed,\n                                        guaranteedRight,\n                                        countLeft,\n                            currentPerm.nextIndex + 1);\n            return newPerm;\n        } else {\n            return null;\n        }\n    }\n\n}\n\n\n// let pResults = p.getPerms([-1,-1,-1,-1,-1,-1],\n//     [new Set<number>([1,2,3,4,5,6]), new Set<number>([1,2,3,4,5,6]), new Set<number>([1,2,3,4,5,6]), new Set<number>([1,2,3,4,5,6]), new Set<number>([1,2,3,4,5,6]), new Set<number>([1,2,3,4,5,6])],\n//     {left: 3, right: 4});\n// //\n// let perPosition = [new Set<number>(), new Set<number>(), new Set<number>(), new Set<number>(), new Set<number>(), new Set<number>(), new Set<number>()];\n// //\n// pResults.forEach(perm => {\n//     for (let i = 0; i<perm.row.length; i++) {\n//         perPosition[i].add(perm.row[i]);\n//     }\n// })\n// console.log(pResults)\n// console.log(perPosition.map(x => Array.from(x).sort()))\n"]}